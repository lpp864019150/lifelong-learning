# 零拷贝技术

## 参考资料

1. [一文搞懂什么是零拷贝 - 掘金](https://juejin.cn/post/7262207330087583803)
2. [一文彻底弄懂零拷贝原理 - 掘金](https://juejin.cn/post/6995519558475841550)
3. [搞明白什么是零拷贝，就是这么简单 - 掘金](https://juejin.cn/post/7270519061207908352)

## 概念

1. 零拷贝
   
   `Zero Copy`
   
   正常的数据需要从磁盘读取到内核缓存区，`DMA`拷贝，用户需要用到时需要由内核进行一次`CPU`拷贝到用户空间，然后再拷贝到具体的进程内存空间
   
   所谓的零拷贝并非正的无需拷贝，只是无需从内核拷贝到用户空间，减少`CPU`拷贝次数以及减少上下文切换

2. `DMA`
   
   `Direct Memory Access`，需要通过驱动

3. `SG-DMA`
   
   `The Scatter-Gather Direct Memory Access`，分散/收集功能
   
   `Linux`需不小于`2.4`版本，且需要网卡支持

4. 虚拟内存
   
   非无论内存地址，而是虚拟的一个地址，每个进程单独管理自己的虚拟地址，不同进程的虚拟地址可以映射到同一个物理地址

5. 地址映射
   
   类似传址而非传值

## 实现

> 传统`I/O`需要经过`4`次上下文切换和`4`次拷贝，其中`2`次`CPU`拷贝，`2`次`DMA`拷贝

1. `sendfile`
   
   传递文件描述符代替数据拷贝
   
   `2`次上下文切换，`1`次`CPU`拷贝(若支持`SG-DMA`则此处可以省去)，`2`次`DMA`拷贝

2. `mmap`
   
   内核地址与用户空间地址进行映射，避免了一次内核空间`CPU`拷贝到用户空间的操作，但是内核依然有一次`CPU`拷贝
   
   `4`次上下文切换，`1`次`CPU`拷贝，`2`次`DMA`拷贝

3. `direct I/O`
   
   用户空间直接与磁盘和网卡进行数据拷贝，绕过了内核空间
   
   `0`次上下文切换，`2`次`DMA`拷贝

4. `splice`
   
   通过管道来传输数据，从内核缓冲区通过管道传输到套接字缓冲区
   
   `2`次上下文切换，`2`次`DMA`拷贝，在新版本的`Linux`里`sendfile`底层用的就是`splice`

## 使用

1. `NIO`，`new I/O`

2. `epoll`，多路复用`I/O`

3. `Kafka`，使用`sendfile`
