# 使用场景

## 参考博文

1. [Redis实战篇：Redis分布式锁无死角分析_51CTO博客_redis setnx 分布式锁](https://blog.51cto.com/MageByte/2930601)

2. [Redis 16 个常见使用场景_redis使用场景_Young丶的博客-CSDN博客](https://blog.csdn.net/agonie201218/article/details/123640871)

3. [Redis的20种使用场景_redis使用场景_六六的小帅的博客-CSDN博客](https://blog.csdn.net/baidu_38493460/article/details/130500729)

4. [Redis篇：事务和lua脚本的使用 - 掘金](https://juejin.cn/post/7032885787515420708)

5. [使用高斯Redis实现二级索引 - 掘金](https://juejin.cn/post/7117561797132959781)

6. [从清档需求谈谈 Redis 二级索引的使用](https://zhuanlan.zhihu.com/p/102482586)

## 场景一：缓存

> 这里我们需要明确什么叫缓存，缓存就是把数据结果存起来，然后再次使用时无需重新计算，直接拿结果即可。
> 
> 那么为什么要缓存呢，因为实时计算得到结果代价比较高，耗费资源或时间。

1. 【Strings】使用`Strings`对需要缓存的内容设置一个合理的`key`，然后把内容格式化为数字或者`String`甚至二进制作为`value`，再设置一个合理的过期时间
   
   > 非简单数据类型的值，可以先`JSON`为字符串后再缓存，当然这同样作用于`key`和`value`，一般`key`太长或者太复杂，我们还可以考虑对其进行`md5`，再加一个前缀进行区分

2. 【Hashes】对于对象，还可以考虑使用`Hashes`来缓存，把成员变量作为`field`值格式化为数字或者`String`甚至二进制作为`value`，再设置一个合理的过期时间
   
   > 在`hyperf`里，数据库的单条记录的缓存就是使用的`Hashes`，可以针对单个字段的变更而修改单个`field`，避免了每次修改整个`json`

3. 【Lists】对于列表，分页，可以考虑使用`Lists`来缓存，当然也可以把分页数据序列化存到一个`Strings`里

> ps. 使用其他数据类型来缓存的情况比较少，主要是`Strings`和`Hashes`

## 场景二：分布式锁

> 何为分布式锁，分布在多台机器，多个用户的请求，需要对同一个锁进行加解锁，使用文件的化无法解决多台机的问题，所以需要一个多台机器可以共同访问的服务来提供服务

1. 【Strings】使用`Strings`进行加解锁，无论多少台机器访问只有一个请求可以获取到锁，这里主要利用了`set`命令的多参数原子性
   
   ```shell
   # nx为第一次设置，也即排他获取锁，ex设置过期时间
   set key value nx ex 20
   ```

> 这里主要需注意几个问题：一、需原子性；二、需设置过期时间，防止无法解锁；三、设置一个唯一值，避免解锁了别人加的锁；四、解锁时使用`Lua`脚本达到原子性。
> 
> ps. 过期时间需要谨慎考虑，如果设置的太短，则锁提前失效会被其他程序重新获得，也就失去了锁的意义，这里有一个解决方案，可以对锁进行轮询，若快过期了可以进行续期。还可以使用比较笨的办法，在预估时间上再增加一段时间宁可锁住不可提前失效

## 场景三：计数器

1. 【Strings】使用`incr`对某个`key`自增从而达到计数器的功能。

2. 【Hashes】若有多个有关联的`key`，可以考虑使用`Hashes`来节省空间`Hincrby`，一个`key`多个`field`，简化一下可以节省不少`key`资源

3. 【Sorted Sets】当然有序集也可以实现自增`Zincrby`，并且还提供了排序功能，在需要排序时可以考虑使用，若无需排序则还是考虑上面的方案，毕竟有序集空间和时间不占优

## 场景四：消息队列

1. 【Lists】先进后出或者后进先出

2. 【Sorted Sets】可以对值进行排序，若无需特殊排序，有序集在此场景并不占优

## 场景五：延时队列

1. 【Sorted Sets】以过期时间为`score`，轮询获取过期时间的值，然后逐个处理从而达到延时队列的效果

## 场景六：获取随机值、抽奖

1. 【Sets】可以使用`Srandmember`来随机获取一个或多个值

2. 【Sorted Sets】可以使用`Zrandmember`来随机获取一个或多个值，并不占优

## 场景七：排行榜

1. 【Sorted Sets】使用有序集的`score`进行排序，使用`Zincrby`来维护`score`的值

## 场景八：去重

1. 【Sets】把成员放入集合即可天然进行去重

2. 【Sorted Sets】单纯的去重，时间空间来说，并不占优

## 场景九：共同好友

1. 【Sets】`Sinter`两个好友集合进行交集处理即可得到共同好友

2. 【Sorted Sets】`Sinter`单纯的交并差集，时间空间来说，并不占优

3. 【Bitmaps】可以利用`Bitmaps`进行存储好友`ID`，然后取交集，随着`ID`的值变大，这个方案会更占空间

## 场景十：全局ID

1. 【Strings】`incr`、`incrby`进行自增，多服务器可以保证`ID`的唯一性

## 场景十一：限流

1. 【Strings】类似计时器，在达到一定数量后进行限流

## 场景十二：时间线、最新帖、最新评论

1. 【Lists】使用后进先出或者先进先出来展示最近最迟的消息记录

## 场景十三：BloomFilter

1. 【Bitmaps】使用三种`hash`算法分别计算，然后设置`bit`位，在判断时，若三个`bit`位都是1则证明存在，否则不存在，这里存在一定的误差率，证明存在可能有一定比例不存在，证明不存在则真的不存在

## 场景十四：补全搜索框，二级索引

1. 【Zsets】使用`memeber`拼接使用频率，然后`score`都设置为`0`，使用`ZRANGEBYLEX myindex "[search" "[search\xff"`(假设搜索词为`search`)进行范围查询，相同`score`的元素按字典排序，这个可以拓展到很多`member`排序的场景里：姓名排序、电话号码排序

## 场景十五：删除相关缓存，二级索引

1. 【Sets】有些时候我们更新了某个记录的值，这条记录可能同时被多个`key`缓存，可能是单个的值，也可能是某个列表，若场景比较少我们可以简单的在代码里面逐一列出来，然后进行删除，若场景非常多，则可以维护一个`Sets`，把需要删除的key放入集合，在需要删除时遍历再删除即可
   
   > 这里可以优化，把相关`key`的模板塞入`Sets`，然后再把模板根据具体的`ID`转换为需要删除的`key`。这样做的好处是达到了通用，避免每个`ID`去单独维护一个`Sets`
