# MySQL与Redis缓存一致性

## 参考博文

1. [进大厂的绊脚石：Redis与MySQL双写一致性如何保证？](https://mp.weixin.qq.com/s/_RQ98YSrtO24vygLT-KxqQ)

2. [掘地三尺搞定 Redis 与 MySQL 数据一致性问题 - 掘金](https://juejin.cn/post/7110120022848045092)

## 三个经典缓存方案

1. Cache-Aside Pattern(旁路缓存模式)
   
   读：先读缓存->若不存在则读数据库->设置缓存->返回数据
   
   写：更新数据库->删除缓存

2. Read-Through/Write-through(读写穿透)
   
   提供一个抽象层，由他负责读写数据。抽象层的步骤和上面基本一致

3. Write-behind(异步缓存写入)
   
   和上面一样也是需要一个抽象层，但是入库操作变更为非实时，而是采用异步分批入库，在某种特殊场景下可使用该方案，不过大部分情况不合适。

> 业内一般使用第一种旁路缓存模式

## 解决一致性问题

> 基于旁路缓存模式

1. 延时双删
   
   操作流程：删除缓存->更新db->休眠一定时间->再次删除缓存
   
   为何不使用更新缓存而使用删除缓存呢，这是避免更新操作时用的是旧数据，若删除了则由下一次获取来决定，这样获取时需要重新从db拿数据。
   
   为何要休眠一定时间呢，这个是避免有读逻辑正在读取旧数据但未设置缓存，若此时删除缓存，则依然设置了旧数据，依然没有达到效果。若我们考虑到读取时间和设置缓存时间，休眠之后即使被重新设置了旧数据也会被删除，那么旧数据被读取的时间最多就是休眠的这一小段时间，一般情况下是可以接受的。
   
   是否可以判定若无缓存则休眠，若有缓存则立即删除。这是因为有缓存了则不可能有正在读取db的操作，无缓存则有可能有别的请求正在读取db。

2. 删除缓存重试机制
   
   维护一个删除失败的key，放入MQ，利用ack机制，多次重试删除

3. 读取binlog异步删除缓存
   
   利用canal读取binlog，然后解析需要删除的key，异步删除，若失败了维护一个MQ，进行重试

## 总结

1. 强一致性，db和缓存融为一体，两者完全无差异

2. 弱一致性，缓存不保证何时更新到与db一致，但是会尽量更新到一致

3. 最终一致性，弱一致性的一种情况，保证在一定时间内缓存与db一致

> 使用缓存的情况下我们无法达到强一致性，只能追求最终一致性，若要求强一致性，则不能使用缓存，在合适的业务场景里使用合适的技术方案，不能为了技术而技术
